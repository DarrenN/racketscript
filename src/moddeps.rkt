#lang racket

(require syntax/moddep
         graph
         threading)

(provide follow-symbol
         get-export-tree
         get-module-deps
         make-module-name-map
         module-deps/tsort
         module-deps/tsort-inv)

;; There are particularly two way's we can figure out what to export
;; and import in a module.
;;
;; 1. Parse require and provide specs. This although obvious and and
;;    likely preferred way, doesn't fit well with ES6 module
;;    system. In ES6 there is nothing like (all-defined-out) which
;;    exports all bindings in current namespace. This implies that
;;    we have to export each identifier individually, resulting in
;;    exponential growth of import/export statements.
;;
;; 2. Considering the drawback discussed and importance of generating
;;    compact code, we instead import each module as an object. With
;;    help of ExportTree and `identifier-binding` function we can
;;    follow each binding to its exact source.
;;
;;    Map generated by `make-module-name-map` will help us give a
;;    unique name to to each module object for ModulePath.

;; ExportTree is (Map ModulePath ExportOriginMap)
;;
;;   Map from a module path to list of all exports from that module,
;;   paired with origin of each of those exports.

;; ExportOriginMap is (Map Symbol (Maybe (Pairof ModulePath Symbol)))
;;
;;   Map between a Symbol which represents an exported identifier
;;   of module. The mapped value is either false if identifier is
;;   defined in current module, or (Pairof ModulePath Symbol) where
;;   car is path of module from which identifier is imported and
;;   cdr is name of this identifier in that module.

;; ExportTree ResolvedModulePath Symbol -> (Pairof (Listof ModulePath) Symbol)
;; Track the modules from where id is imported starting from
;; src. We except id to be present in src. Only exports are
;; checked at each level, not imports. Returned value is a
;; a pair, where car is list of modules to follow and cdr is
;; the identifier name exported by module where it is defined
;; WHERE: `id` must expoted at src
(define (follow-symbol tree src id)
  (define (result src* id*)
    (cons (reverse src*) (first id*)))
  (let loop ([src* (list src)]
             [id* (list id)])
    (define module-exports (hash-ref tree (first src*)))
    (match (hash-ref module-exports (first id*))
      [(cons (? symbol? next-module) next-id)
       ;; When module name is a symbol such as #%kernel, #%unsafe ...
       (result (cons next-module src*)
               (cons next-id id*))]
      [(cons next-module next-id)
       (loop (cons next-module src*)
             (cons next-id id*))]
      [#f (result src* id*)])))

;; ModulePath -> ExportTree
;; Return whole tree of exports with its source starting
;; from mod-name (ModulePath)
(define (get-export-tree mod-name)
  (define modules (module-deps/tsort-inv (get-module-deps mod-name)))
  (for/hash ([m modules])
    (values m (get-exports/modpath m))))

;; ModulePath -> ExportOriginMap
;; For module at mod-path, returns a map of exported
;; identifiers with their corresponding origin module. If
;; identifier maps to #f, it is defined in mod-path itself.
(define (get-exports/modpath mod-path)
  (~> (resolve-module-path mod-path #f)
      (get-module-code _)
      (get-exports mod-path _ )
      (make-immutable-hash _)))

;; ModulePath CompiledModule -> ExportOriginMap
;; Like get-exports/modpath, except it takes compiled module
;; code. mod-path is source path of mod-code. We need this to
;; resolve path indexes produced by `module-compiled-exports`
(define (get-exports mod-path mod-code)
  ;; Takes a module exports entry in form (Pairof Symbol (Listof
  ;; ModPathIndex)) and return (list Symbol (Maybe ModPathIndex))
  (define (fix-entry e)
    (match e
      [(list id '()) (cons (first e) #f)]
      [(list id (list (? module-path-index? mod) ...))
       (cons id (cons (resolve-module-path-index (first mod) mod-path)
                      id))]
      [(list id (list
                 (list
                  (? module-path-index? mod) _ (? symbol? orig-name) _) ...))
       (cons id (cons (resolve-module-path-index (first mod) mod-path)
                      (first orig-name)))]))
  (define-values (exports _) (module-compiled-exports mod-code))
  (for/fold ([r '()])
            ([i* exports])
    (match i*
      [(list 0 entry ...)
       (append r (map fix-entry entry))]
      [_ r])))

;; (Map Path (Listof Path)) -> (Listof Path)
;; Topologically sorted module dependency graph
(define (module-deps/tsort-inv mod-deps)
  (~> (hash->list mod-deps)
      (unweighted-graph/adj _)
      (tsort _)))
(define (module-deps/tsort mod-deps)
  (~> (hash->list mod-deps)
      (unweighted-graph/adj _)
      (transpose _)
      (tsort _)))

;; Path -> (Map Path (Listof Path))
;; Returns a adjecency map of module imports
(define (get-module-deps mod-path)
  (define graph (make-hash))
  (define (build-graph mod-path)
    (define path (resolve-module-path mod-path #f))
    (define code (get-module-code path))
    (define imports (module-compiled-imports code))
    (hash-set! graph path '())
    (for ([r imports])
      (match-define (cons i mods) r)
      (for ([mod mods])
        (match (resolve-module-path-index mod path)
          [#f (void)]
          [`(submod ,path ,mod) (void)]
          [(? symbol? b) (void)]
          [`,resolved-path (define new-mod (simplify-path resolved-path))
                           (hash-update! graph path (Î» (v) (cons new-mod v)))
                           (unless (hash-ref graph new-mod #f)
                             (build-graph new-mod))]))))
  (build-graph mod-path)
  graph)


;; (Listof ModuleName) -> (Map ModuleName Symbol)
;; Maps each module name with a unique name
(define (make-module-name-map mods)
  (for/hash ([m mods]
             [i (in-naturals)])
    (values m (string->symbol (format "m~a" i)))))
